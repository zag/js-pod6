#!/usr/bin/env node
const fs = require('fs')
const getAllowed = ( originGrammar)=>{
    const allowed_rules  = originGrammar.toString().match(/allowed_rules\s=(.*)/)[1]
    const allowed_code = originGrammar.toString().match(/allowed_code\s=(.*)/)[1]
    // collect all codes with rules
    let rulesFc =[]
    const reg = /code_(\w)/g
    let result = []
    while((result = reg.exec(allowed_rules)) !== null) {
        rulesFc.push(result[1])
    }

    // collect all supported rules
    let codesFc = []
    const regCodes = /\'(\w)\'/g
    while((result = regCodes.exec(allowed_code)) !== null) {
        codesFc.push(result[1])
    }
    return {
        rulesFc,
        codesFc
    }

}

// read original pegjs file
const grammarsFc = fs.readFileSync('./src/grammarfc.pegjs')
const {codesFc, rulesFc} = getAllowed(grammarsFc)

// collect all codes
const b = [...codesFc, ...rulesFc].reduce((a,b ) => {
    if (!a.includes(b))  a.push(b) 
    return a},[]).sort()
let results= [];
// generate all possible cobination
let uniqFc = (result) => result.filter(i=>i!=='').reduce(
    ( a, i ) => {
        if( !a.includes(i) ) a.push(i);
        return a
    }
    ,[])
function combinations(str) {
        var fn = function(active, rest, a) {
            if (!active && !rest)
                return;
            if (!rest) {
                a.push(active);
            } else {
                fn(active + rest[0], rest.slice(1), a);
                fn(active, rest.slice(1), a);
            }
            return a;
        }
        return fn("", str, []);
}
let uniq = uniqFc(combinations(b.join('')))
console.log(`generate  ${uniq.length}`)
// generate grammars
const makeGrammar = ( origin, allowedCodes ) => {
    const {codesFc, rulesFc} = getAllowed(grammarsFc)
    const allowed = allowedCodes.split('')
    const rules = allowed.filter((i)=>rulesFc.includes(i))
    const rulesString = rules.map(i=>`code_${i}`).join(' / ') || '"__EMPTY_RULES_SET__"&{return false}'
    const codesString = allowed.map(i=>`'${i}'`).join(' / ') || '"__EMPTY_CODE_SET__"&{return false}'
    // now make grammar
    let newTemplate = origin.replace(/(\s*allowed_rules\s*=\s*)(.*)/,'$1' + rulesString)
    newTemplate = newTemplate.replace(/(\s*allowed_code\s*=\s*)(.*)/,'$1' + `(${codesString})`)
    return newTemplate
}
// allow combination -> filename
let allowFileMap = []
// generate files with compiled grammars
//uniq=['I']
for (let i = 0; i < uniq.length; i++) {
const allowStr = uniq[i]
// console.log(uniq)
const res = makeGrammar(grammarsFc.toString(), allowStr )
// generate grammar and save
var peg = require("pegjs");
var parser = peg.generate(res, {output:'source', format:'commonjs'});
const filePath = `src/fc-grammars/fc-${allowStr}.js`
const filePegjsPath = `src/fc-grammars/fc-${allowStr}.pegjs`
const filename = `fc-${allowStr}.js`
fs.writeFileSync(filePath, parser)
fs.writeFileSync(filePegjsPath, res)
allowFileMap.push({ code: allowStr, filename, filePath, })
}
// make index file
const includes = allowFileMap.map(({code, filename}) => {
    return `module.exports.${code} = require('./${filename}')`
}).join('\n')
fs.writeFileSync('src/fc-grammars/index.js', includes)
